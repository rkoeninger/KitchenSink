<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>using System;

namespace KitchenSink
{
    public static class Match
    {
        public static MatcherK0<A> On<A>(A k)
        {
            return new MatcherK0<A>(k);
        }

        public static MatcherKD0<A, B> On<A, B>(A k, Func<A, B> defaultF)
        {
            return new MatcherKD0<A, B>(k, defaultF);
        }

        public static Matcher0<A> From<A>()
        {
            return new Matcher0<A>();
        }
    }

    public static class Match<A>
    {
        public static MatcherK0<A> On(A k)
        {
            return new MatcherK0<A>(k);
        }

        public static MatcherKD0<A, B> On<B>(A k, Func<A, B> defaultF)
        {
            return new MatcherKD0<A, B>(k, defaultF);
        }

        public static Matcher0<A, B> Return<B>()
        {
            return new Matcher0<A, B>();
        }

        public static MatcherD0<A, B> Default<B>(Func<A, B> v)
        {
            return new MatcherD0<A, B>(v);
        }

        public static MatcherD0<A, B> Default<B>(Func<B> v)
        {
            return new MatcherD0<A, B>(_ => v());
        }

        public static MatcherD0<A, B> Default<B>(B v)
        {
            return new MatcherD0<A, B>(_ => v);
        }
        <# CaseOverloads(true, true, "Matcher1"); #>
    }

    public static class Match<A, B>
    {
        public static MatcherK0<A, B> On(A k)
        {
            return new MatcherK0<A, B>(k);
        }

        public static MatcherKD0<A, B> On(A k, Func<A, B> defaultF)
        {
            return new MatcherKD0<A, B>(k, defaultF);
        }

        public static MatcherD0<A, B> Default(Func<A, B> v)
        {
            return new MatcherD0<A, B>(v);
        }

        public static MatcherD0<A, B> Default(Func<B> v)
        {
            return new MatcherD0<A, B>(_ => v());
        }

        public static MatcherD0<A, B> Default(B v)
        {
            return new MatcherD0<A, B>(_ => v);
        }
        <# CaseOverloads(false, true, "Matcher1"); #>
    }

    /// <remarks>Key may be ignored, depending on implementation.</remarks>
    internal interface IMatcher<in A, B>
    {
        Maybe<B> Eval(A k);
    }

    public class Matcher0<A>
    {
        internal Matcher0()
        {
        }

        public Matcher0<A, B> Return<B>()
        {
            return new Matcher0<A, B>();
        }
        <# Defaults(true, "MatcherD0", "", ""); #>
        <# CaseOverloads(true, false, "Matcher1", ""); #>
    }

    <# Class("Matcher0"); #>
        <# Eval("Maybe<B>.None"); #>
        <# End("Func<A, Maybe<B>>", "Eval"); #>
        <# Else(true); #>
        <# On("MatcherK0", "k"); #>
        <# Defaults(false, "MatcherD0", "", ""); #>
        <# CaseOverloads(false, false, "Matcher1"); #>
        <# CaseSubtypeOverloads("Matcher1"); #>
    <# EndClass(); #>

    <# Class("Matcher1", ConditionParam, ConsequentParam); #>
        <# Eval("Maybe.If(k, Condition, Consequent)"); #>
        <# End("Func<A, Maybe<B>>", "Eval"); #>
        <# Else(true); #>
        <# On("MatcherK1", "k, Condition, Consequent"); #>
        <# Defaults(false, "MatcherD1", "", ", Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherN", "this, "); #>
        <# CaseSubtypeOverloads("MatcherN", "this, "); #>
    <# EndClass(); #>

    <# Class("MatcherN", PreviousParam, ConditionParam, ConsequentParam); #>
        <# Eval("Previous.Eval(k).OrIf(k, Condition, Consequent)"); #>
        <# End("Func<A, Maybe<B>>", "Eval"); #>
        <# Else(true); #>
        <# On("MatcherKN", "k, Previous, Condition, Consequent"); #>
        <# Defaults(false, "MatcherDN", "this, ", ", Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherN", "this, "); #>
        <# CaseSubtypeOverloads("MatcherN", "this, "); #>
    <# EndClass(); #>

    <# Class("MatcherD0", DefaultParam); #>
        <# Eval("Maybe<B>.None"); #>
        <# End("Func<A, B>", "Default"); #>
        <# On("MatcherKD0", "k, Default"); #>
        <# CaseOverloads(false, false, "MatcherD1", "Default, "); #>
        <# CaseSubtypeOverloads("MatcherD1", "Default, "); #>
    <# EndClass(); #>

    <# Class("MatcherD1", DefaultParam, ConditionParam, ConsequentParam); #>
        <# Eval("Maybe.If(k, Condition, Consequent)"); #>
        <# End("Func<A, B>", "k => me.Eval(k).OrElseEval(k, me.Default)"); #>
        <# On("MatcherKD1", "k, Default, Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherDN", "this, Default, "); #>
        <# CaseSubtypeOverloads("MatcherDN", "this, Default, "); #>
    <# EndClass(); #>

    <# Class("MatcherDN", PreviousParam, DefaultParam, ConditionParam, ConsequentParam); #>
        <# Eval("Previous.Eval(k).OrIf(k, Condition, Consequent)"); #>
        <# End("Func<A, B>", "k => me.Eval(k).OrElseEval(k, me.Default)"); #>
        <# On("MatcherKDN", "k, Default, this, Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherDN", "this, Default, "); #>
        <# CaseSubtypeOverloads("MatcherDN", "this, Default, "); #>
    <# EndClass(); #>

    public class MatcherK0<A>
    {
        internal MatcherK0(A k)
        {
            Key = k;
        }

        private readonly A Key;

        public MatcherK0<A, B> Return<B>()
        {
            return new MatcherK0<A, B>(Key);
        }
        <# Defaults(true, "MatcherKD0", "Key, ", ""); #>
        <# CaseOverloads(true, false, "MatcherK1", "Key, "); #>

    }

    <# Class("MatcherK0", KeyParam); #>
        <# Eval("Maybe<B>.None"); #>
        <# End("Maybe<B>", "Eval(Key)"); #>
        <# Else(false); #>
        <# Defaults(false, "MatcherKD0", "Key, ", ""); #>
        <# CaseOverloads(false, false, "MatcherK1", "Key, "); #>
        <# CaseSubtypeOverloads("MatcherK1", "Key, "); #>
    <# EndClass(); #>

    <# Class("MatcherK1", KeyParam, ConditionParam, ConsequentParam); #>
        <# Eval("Maybe.If(Key, Condition, Consequent)"); #>
        <# End("Maybe<B>", "Eval(Key)"); #>
        <# Else(false); #>
        <# Defaults(false, "MatcherKD1", "Key, ", ", Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherKN", "Key, this, "); #>
        <# CaseSubtypeOverloads("MatcherKN", "Key, this, "); #>
    <# EndClass(); #>

    <# Class("MatcherKN", KeyParam, PreviousParam, ConditionParam, ConsequentParam); #>
        <# Eval("Previous.Eval(Key).OrIf(Key, Condition, Consequent)"); #>
        <# End("Maybe<B>", "Eval(Key)"); #>
        <# Else(false); #>
        <# Defaults(false, "MatcherKDN", "Key, ", ", this, Condition, Consequent"); #>
        <# CaseOverloads(false, false, "MatcherKN", "Key, this, "); #>
        <# CaseSubtypeOverloads("MatcherKN", "Key, this, "); #>
    <# EndClass(); #>

    <# Class("MatcherKD0", KeyParam, DefaultParam); #>
        <# Eval("Maybe<B>.None"); #>
        <# End("B", "Default(Key)"); #>
        <# CaseOverloads(false, false, "MatcherKD1", "Key, Default, "); #>
        <# CaseSubtypeOverloads("MatcherKD1", "Key, Default, "); #>
    <# EndClass(); #>

    <# Class("MatcherKD1", KeyParam, DefaultParam, ConditionParam, ConsequentParam); #>
        <# Eval("Maybe.If(Key, Condition, Consequent)"); #>
        <# End("B", "Eval(Key).OrElseEval(Key, Default)"); #>
        <# CaseOverloads(false, false, "MatcherKDN", "Key, Default, this, "); #>
        <# CaseSubtypeOverloads("MatcherKDN", "Key, Default, this, "); #>
    <# EndClass(); #>

    <# Class("MatcherKDN", KeyParam, DefaultParam, PreviousParam, ConditionParam, ConsequentParam); #>
        <# Eval("Previous.Eval(Key).OrIf(Key, Condition, Consequent)"); #>
        <# End("B", "Eval(Key).OrElseEval(Key, Default)"); #>
        <# CaseOverloads(false, false, "MatcherKDN", "Key, Default, this, "); #>
        <# CaseSubtypeOverloads("MatcherKDN", "Key, Default, this, "); #>
    <# EndClass(); #>
}

<#+
    public class Param
    {
        public String Type;
        public String Arg;
        public String Property;
    }

    Param KeyParam = new Param { Type = "A", Property = "Key", Arg = "k" };
    Param DefaultParam = new Param { Type = "Func<A, B>", Property = "Default", Arg = "defaultF" };
    Param PreviousParam = new Param { Type = "IMatcher<A, B>", Property = "Previous", Arg = "m" };
    Param ConditionParam = new Param { Type = "Func<A, bool>", Property = "Condition", Arg = "p" };
    Param ConsequentParam = new Param { Type = "Func<A, B>", Property = "Consequent", Arg = "f" };

    public void Class(String className, params Param[] args)
    {
        WriteLine("public class " + className + "<A, B> : IMatcher<A, B>");
        WriteLine("    {");
        WriteLine("        internal " + className + "(" + String.Join(", ", args.Select(x => x.Type + " " + x.Arg)) + ")");
        WriteLine("        {");

        foreach (var arg in args)
            WriteLine("            " + arg.Property + " = " + arg.Arg + ";");

        WriteLine("        }");
        WriteLine("");

        foreach (var arg in args)
            WriteLine("        private readonly " + arg.Type + " " + arg.Property + ";");
    }

    public void EndClass()
    {
        WriteLine("}");
    }

    public void End(String returnType, String expr)
    {
        WriteLine("public " + returnType + " End");
        WriteLine("        {");

        if (expr.Contains("me"))
        {
            WriteLine("            get");
            WriteLine("            {");
            WriteLine("                var me = this;");
            WriteLine("                return " + expr + ";");
            WriteLine("            }");
        }
        else
        {
            WriteLine("            get { return " + expr + "; }");
        }

        WriteLine("        }");
    }

    public void On(String className, String args)
    {
        WriteLine("public " + className + "<A, B> On(A k)");
        WriteLine("        {");
        WriteLine("            return new " + className + "<A, B>(" + args + ");");
        WriteLine("        }");
    }

    public void Eval(String expr)
    {
        WriteLine("public Maybe<B> Eval(A k)");
        WriteLine("        {");
        WriteLine("            return " + expr + ";");
        WriteLine("        }");
    }

    public void Else(bool func)
    {
        var consequences = new List<Tuple<String, String, String>> {
            Tuple.Create("Func<A, B> f", "k => me.End(k).OrElseEval(k, f)", "End.OrElseEval(Key, f)"),
            Tuple.Create("Func<B> f",    "k => me.End(k).OrElseEval(f)",    "End.OrElseEval(f)"),
            Tuple.Create("B f",          "k => me.End(k).OrElse(f)",        "End.OrElse(f)")
            };

        foreach (var conseq in consequences)
        {
            WriteLine("");
            WriteLine("        public " + (func ? "Func<A, B>" : "B") + " Else(" + conseq.Item1 + ")");
            WriteLine("        {");

            if (func)
                WriteLine("            var me = this;");

            WriteLine("            return " + (func ? conseq.Item2 : conseq.Item3) + ";");
            WriteLine("        }");
        }
    }

    public void Defaults(bool typeArg, String className, String beforeArgs, String extraArgs)
    {
        var consequences = new List<Tuple<String, String>> {
            Tuple.Create("Func<A, B> defaultF", "defaultF"),
            Tuple.Create("Func<B> defaultF",    "_ => defaultF()"),
            Tuple.Create("B defaultF",          "_ => defaultF")
        };

        foreach (var conseq in consequences)
        {
#>

        public <#= className #><A, B> Default<#= typeArg ? "<B>" : "" #>(<#= conseq.Item1 #>)
        {
            return new <#= className #><A, B>(<#= beforeArgs #><#= conseq.Item2 #><#= extraArgs #>);
        }
<#+
        }
    }

    public void CaseOverloads(bool infer, bool statik, String className)
    {
        CaseOverloads(infer, statik, className, "");
    }

    public void CaseOverloads(bool infer, bool statik, String className, String extraArgs)
    {
        var conditions = new List<Tuple<String, String>> {
            Tuple.Create("Func<A, bool> p", "p"),
            Tuple.Create("Func<bool> p",    "_ => p()"),
            Tuple.Create("bool p",          "_ => p"),
            Tuple.Create("A p",             "x => Equals(x, p)"),
            Tuple.Create("Type p",          "x => p.IsInstanceOfType(x)")
        };

        var consequences = new List<Tuple<String, String>> {
            Tuple.Create("Func<A, B> f", "f"),
            Tuple.Create("Func<B> f",    "_ => f()"),
            Tuple.Create("B f",          "_ => f")
        };

        foreach (var cond in conditions)
        {
            foreach (var conseq in consequences)
            { #>

        public <#= statik ? "static " : "" #><#= className #><A, B> Case<#= infer ? "<B>" : "" #>(<#= cond.Item1 #>, <#= conseq.Item1 #>)
        {
            return new <#= className #><A, B>(<#= extraArgs #><#= cond.Item2 #>, <#= conseq.Item2 #>);
        }
        <#+ }
        }
    }

    public void CaseSubtypeOverloads(String className)
    {
        CaseSubtypeOverloads(className, "");
    }

    public void CaseSubtypeOverloads(String className, String extraArgs)
    {
        var conditions = new List<Tuple<String, String, bool>> {
            Tuple.Create("Func<C, bool> p", "x => x is C && p((C) x)", true),
            Tuple.Create("Func<bool> p",    "_ => p()",                false),
            Tuple.Create("bool p",          "_ => p",                  false)
        };

        var consequences = new List<Tuple<String, String, bool>> {
            Tuple.Create("Func<C, B> f", "x => f((C) x)", true),
            Tuple.Create("Func<B> f",    "_ => f()",      false),
            Tuple.Create("B f",          "_ => f",        false)
        };

        foreach (var cond in conditions)
        {
            foreach (var conseq in consequences.Where(x => x.Item3 && cond.Item3))
            { #>

        public <#= className #><A, B> Case<C>(<#= cond.Item1 #>, <#= conseq.Item1 #>) where C : A
        {
            return new <#= className #><A, B>(<#= extraArgs #><#= cond.Item2 #>, <#= conseq.Item2 #>);
        }
<#+			}
        }

        foreach (var conseq in consequences.Where(x => x.Item3))
        { #>

        public <#= className #><A, B> Case<C>(<#= conseq.Item1 #>) where C : A
        {
            return new <#= className #><A, B>(<#= extraArgs #>x => x is C, <#= conseq.Item2 #>);
        }
<#+     }
    } #>